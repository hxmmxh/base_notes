# 编译和调试程序

* [文件的编译过程](#文件的编译过程)
* [gcc](#gcc)
* [gdb](#gdb)
  * [功能简介](#功能简介)
  * [启动和退出](#启动和退出)
  * [暂停和调试](#暂停和调试)
  * [查看源代码信息](#查看源代码信息)
  * [查看栈信息](#查看栈信息)
  * [查看运行时信息](#查看运行时信息)
  * [改变程序的执行](#改变程序的执行)
  * [常用命令汇总](#常用命令汇总)

## 文件的编译过程

1. **预编译**
主要处理源代码文件中的以“#”开头的预编译指令,生成.i或.ii文件。处理规则见下
    1. 删除所有的#define，展开所有的宏定义。
    2. 处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。
    3. 处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。
    4. 删除所有的注释，“//”和“/**/”。
    5. 保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。
    6. 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。
2. **编译**
把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件xxx.s。
    1. 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。
    2. 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。
    3. 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。
    4. 优化：源代码级别的一个优化过程。
    5. 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。
    6. 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。
3. **汇编**
将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。
4. **链接**
将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序

* **静态链接**
函数和数据被编译进一个二进制文件。在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
  * 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
  * 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
  * 运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

* **动态链接**  
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。文件名格式为lib + 动态库名 + .so后缀。
  * 共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；
  * 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
  * 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

## GCC

### gcc编译常用命令选项

- -E
预编译后停下来，生成后缀为 .i 的预编译文件。
- -S
编译后停下来，生成后缀为 .s 的汇编文件。
- -c
汇编后停止下来生成目标文件，不链接成为可执行文件。编译器只是由输入的 .c 等源代码文件生成 .o 为后缀的目标文件，通常用于编译不包含主程序的子程序文件。
- -o output_filename
确定输出文件的名称为output_filename。同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出默认的可执行文件 a.out。
* [补充知识：文件的编译过程](#文件的编译过程)
* -g  
产生符号调试工具（GNU的 gdb）所必要的符号信息。想要对源代码进行调试，就必须加入这个选项。
* -O0，-O1，-O2, -O3  
对程序进行优化编译、链接。采用这个选项，整个源代码会在编译、链接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是编译、链接的速度就相应地要慢一些，而且对执行文件的调试会产生一定的影响，造成一些执行效果与对应源文件代码不一致等一些令人“困惑”的情况。因此，一般在编译输出软件发行版时使用此选项。-O0 表示没有优化, -O1 为默认值，-O3 优化级别最高。
* -v
查看完整和详细的gcc编译过程

* -M
自动找寻源文件中包含的头文件，并生成一个依赖关系

* -MM
作用和-M类似，只是不会包含标准库的头文件

* **警告提示功能选项**

* -w
不生成任何警告信息。
* -Wall
生成所有警告信息。
* -Werror
它要求 gcc 将所有的警告当成错误进行处理，会在所有产生警告的地方停止编译
* -Wcast-align
当源程序中地址不需要对齐的指针指向一个地址需要对齐的变量地址时，则产生一个警告。例如，char*指向一个 int* 地址，而通常在机器中 int 变量类型是需要地址能被2或4整除的对齐地址。

* **库操作选项**

* -Idirname
将 dirname 所指出的目录加入到程序头文件目录列表中  
在你是用 #include "file" 的时候, gcc/g++ 会先在当前目录查找你所制定的头文件, 如果没有找到, 他回到默认的头文件目录找, 如果使用 -I 制定了目录,他会先在你所制定的目录查找, 然后再按常规的顺序去找。
对于 `#include<file>`, gcc/g++ 会到 -I制定的目录查找, 查找不到, 然后将到系统的默认的头文件目录查找 。
* -Ldirname  
将dirname所指出的目录加入到程序函数库文件的目录列表中，是在链接过程中使用的参数。在默认状态下，链接程序 ld 在系统默认路径中（如 /usr/lib）寻找所需要的库文件。这个选项告诉链接程序，首先到 -L 指定的目录中去寻找，然后到系统默认路径中寻找；如果函数库存放在多个目录下，就需要依次使用这个选项，给出相应的存放目录。
* -lname  
链接时装载名为 libname.a 的函数库。该函数库位于系统默认的目录或者由 -L 选项确定的目录下。例如，-lm 表示链接名为 libm.a 的数学函数库。

* **调试选项**

* -g 和 -ggdb
默认情况下，gcc 在编译时不会将调试符号插入到生成的二进制代码中，因为这样会增加可执行文件的大小。如果需要在编译时生成调试符号信息，可以使用 gcc 的 -g 或 -ggdb 选项。
gcc 在产生调试符号时，同样采用了分级的思路，开发人员可以通过在 -g 选项后附加数字1、2、3指定在代码中加入调试信息的多少。默认的级别是2（-g2），此时产生的调试信息包括：扩展的符号表、行号、局部或外部变量信息。
级别3（-g3）包含级别2中的所有调试信息以及源代码中定义的宏。
级别1（-g1）不包含局部变量和与行号有关的调试信息，因此只能够用于回溯跟踪和堆栈转储。
回溯追踪：指的是监视程序在运行过程中函数调用历史。
堆栈转储：则是一种以原始的十六进制格式保存程序执行环境的方法。

注意：使用任何一个调试选项都会使最终生成的二进制文件的大小急剧增加，同时增加程序在执行时的开销，因此，调试选项通常仅在软件的开发和调试阶段使用。

* -p 和 -pg
会将剖析（Profiling）信息加入到最终生成的二进制代码中。剖析信息对于找出程序的性能瓶颈很有帮助，是协助Linux程序员开发出高性能程序的有力工具。

* -save-temps
保存编译过程中生成的一些列中间文件。

`gcc test.c -o test -save-temps`

除了生成执行文件test之外，还保存了test.i 和 test.s 中间文件，供用户查询调试。

-----------------------------------------------

## GDB

* [参考资料](https://blog.csdn.net/haoel/article/month/2003/07)

### 功能简介

* 启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。
* 可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）
* 当程序被停住时，可以检查此时你的程序中所发生的事。
* 动态的改变你程序的执行环境。

### 启动和退出

* 编译器的准备工作
  * 编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点
  * 如果没有-g，将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。
  * 例如`cc -g hello.c -o hello` ， `g++ -g hello.cpp -o hello`
* 载入程序
  * `gdb <program>` program也就是执行文件，一般在当前目录下。
  * `gdb <program> core` 用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。
  * 调试服务程序
    * 在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用`gdb <program> PID`格式挂接正在运行的程序。
    * 先用`gdb <program>`关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。
* 程序运行参数
  * `set args` 可指定运行时参数。（如：set args 10 20 30 40 50）
  * `show args` 命令可以查看设置好的运行参数。
* 运行环境。
  * `path <dir>` 可设定程序的运行路径。
  * `show paths` 查看程序的运行路径。
  * `set environment varname [=value]` 设置环境变量。如：set env USER=hchen
  * `show environment [varname]` 查看环境变量。
* 工作目录
  * `cd <dir>` 相当于shell的cd命令。
  * `pwd` 显示当前的所在目录。
* 程序的输入输出
  * info terminal 显示你程序用到的终端的模式
  * 使用重定向控制程序输出。如：run > outfile
  * tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb
* 设定语言环境
  * `show language`  查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默认的环境。
  * `info frame`    查看当前函数的程序语言。
  * `info source`   查看当前文件的程序语言。
  * `set language` 手动设置当前的程序语言。 当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类
* 启动
  * run或r
* 退出
  * quit或q

#### 运行UNIX的shell程序

* 在gdb环境中，可以执行UNIX的shell的命令，使用gdb的shell命令来完成
* `shell <command string>` 调用UNIX的shell来执行command string，环境变量SHELL中定义的UNIX的shell将会被用来执行command string，如果SHELL没有定义，那就使用UNIX的标准shell：/bin/sh。（在Windows中使用Command.com或cmd.exe）
* `make <make-args>` 可以在gdb中执行make命令来重新build自己的程序。这个命令等价于`shell make <make-args>`。

### 暂停和调试

* 暂停方式包括有：断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops）。
* 如果要恢复程序运行，可以使用c或是continue命令恢复程序的运行直到程序结束，或下一个断点到来。
* 也可以使用step或next命令单步跟踪程序

#### 断点（BreakPoint)

* `break <function>`    在进入指定函数时停住。C++中可以使用class::function或function(type,type)格式来指定函数名。
* `break <linenum>`    在指定行号停住。
* `break +offset`和`break -offset`   在当前行号的前面或后面的offset行停住。offiset为自然数。
* `break filename:linenum`  在源文件filename的linenum行处停住。
* `break filename:function` 在源文件filename的function函数的入口处停住。
* `break *address` 在程序运行的内存地址处停住。
* `break` break命令没有参数时，表示在下一条指令处停住。  
  
* `info break(points) [n]` 可使用info查看断点相关的信息  
  
* `break ... if <condition>` ...可以是上述的参数，condition表示条件，在条件成立时停住。

 > 在C++中，可能会重复出现同一个名字的函数若干次（函数重载），在这种情况下，break 不能告诉GDB要停在哪个函数的入口。当然，你可以使用break 也就是把函数的参数类型告诉GDB，以指定一个函数。否则的话，GDB会给你列出一个断点菜单供你选择你所需要的断点。你只要输入你菜单列表中的编号就可以了

#### 观察点（WatchPoint）

- 观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。
- `watch <expr>`  为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序
- `rwatch <expr>` 当表达式（变量）expr被读时，停住程序。
- `awatch <expr>`  当表达式（变量）的值被读或被写时，停住程序。
- `info watchpoints`  列出当前所设置了的所有观察点。

#### 捕捉点（CatchPoint）

- 设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。
- 设置捕捉点的格式为：`catch <event>`。当event发生时，停住程序。
- event可以是下面的内容：
    1. throw 一个C++抛出的异常。（throw为关键字）
    2. catch 一个C++捕捉到的异常。（catch为关键字）
    3. exec 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）  
    4. fork 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）
    5. vfork 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）
    6. load 或 `load <libname>` 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX下有用)
    7. unload 或 `unload <libname>` 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在HP-UX下有用）
- `tcatch <event>` 只设置一次捕捉点，当程序停住以后，该点被自动删除。

#### 维护停止点

- `clear` 清除所有的已定义的停止点。
- `clear <function>`,`clear <filename:function>`  清除所有设置在函数上的停止点。
- `clear <linenum>`,`clear <filename:linenum>`   清除所有设置在指定行上的停止点。
- `delete [breakpoints] [range...]`  删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。

- disable了的停止点，GDB不会删除，当你还需要时，enable即可
- `disable [breakpoints] [range...]` disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis.
- `enable [breakpoints] [range...]`   enable所指定的停止点，breakpoints为停止点号。
- `enable [breakpoints] [range...]  once`     enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。
- `enable [breakpoints] [range...]  delete`      enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。

#### 条件停止

* 只有break和watch命令支持if，catch目前暂不支持if
* `condition <bnum> <expression>`  修改断点号为bnum的停止条件为expression。
* `condition <bnum>`  清除断点号为bnum的停止条件。
* `ignore <bnum> <count>`   表示忽略断点号为bnum的停止条件count次。

#### 为停止点设定运行命令

* 我们可以使用GDB提供的command命令来设置停止点的运行命令。也就是说，当运行的程序在被停止住时，我们可以让其自动运行一些别的命令，这很有利行自动化调试。对基于GDB的自动化调试是一个强大的支持。
* 为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的命令。

```shell
commands [bnum]
    ... command-list ...
end
```

* 例如：断点设置在函数foo中，断点条件是x>0，如果程序被断住后，也就是，一旦x的值在foo函数中大于0，GDB会自动打印出x的值，并继续运行程序。

```shell
    break foo if x>0
    commands
    printf "x is %d/n",x
    continue
    end
```
rl
* 如果你要清除断点上的命令序列，那么只要简单的执行一下commands命令，并直接在打个end就行了

#### 单步调试

* `continue [ignore-count]`, `c [ignore-count]`,`fg [ignore-count]`  恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。
* `step <count>`  单步跟踪，如果有函数调用，他会进入该函数。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。简写s
* `next <count>`  单步跟踪，如果有函数调用，他不会进入该函数。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。简写n
* `finish`        运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。
* `until 或 u`        当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。
* `stepi 或 si`,`nexti 或 ni`        单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是“display/i $pc” ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）
* `set step-mode on`  打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数有很利于查看机器码。
* `set step-mod off`  关闭step-mode模式

#### 信号（Signals）

* GDB有能力在你调试程序的时候处理任何一种信号，你可以告诉GDB需要处理哪一种信号。你可以要求GDB收到你所指定的信号时，马上停住正在运行的程序，以供你进行调试。
* `handle <signal> <keywords...>`  在GDB中定义一个信号处理。
* 信号signal可以以SIG开头或不以SIG开头，可以用定义一个要处理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。
* 一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。
* keywords可以是以下几种关键字的一个或多个。
  * nostop  当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号。
  * stop  当被调试的程序收到信号时，GDB会停住你的程序。
  * print 当被调试的程序收到信号时，GDB会显示出一条信息。  
  * noprint 当被调试的程序收到信号时，GDB不会告诉你收到信号的信息。
  * pass, noignore 当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序会处理。
  * nopass, ignore  当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。
  * info signals, info handle    查看有哪些信号在被GDB检测中。

#### 线程停止（Thread Stops）

* 如果你程序是多线程的话，你可以定义你的断点是否在所有的线程上，或是在某个特定的线程。GDB很容易帮你完成这一工作。
* `break <linespec> thread <threadno>`    `break <linespec> thread <threadno> if ...`
* linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是GDB分配的，你可以通过“info threads”命令来查看正在运行程序中的线程信息。
* 如果你不指`定thread <threadno>`则表示你的断点设在所有线程上面。你还可以为某线程指定断点条件。
* 当你的程序被GDB停住时，所有的运行线程都会被停住。这方便你你查看运行程序的总体情况。而在你恢复程序运行时，所有的线程也会被恢复运行。那怕是主进程在被单步调试时。

### 查看源代码信息

#### 查看源代码

* `list` 显示刚才打印过的源代码之后的代码，默认情况下,一次显示10行,第一次使用时,从代码起始位置显示
* `list -` 显示刚才打印过的源代码之前的代码
* `list n` 显示以第n行为中心的10行代码
* `list <first>, <last>` 显示从first行到last行之间的源代码。
* `list , <last>` 显示从当前行到last行之间的源代码。
* `list function` 显示以function函数为中心的10行代码
* `list <filename:linenum>`  哪个文件的哪一行。
* `list <filename:function>` 哪个文件中的哪个函数。
* `list <*address>`  程序运行时的语句在内存中的地址。
* 均可用简写l替代list
* `set listsize <count>`设置一次显示源代码的行数。
* `show listsize` 查看当前listsize的设置。

#### 搜索源代码

* `forward-search <regexp> ``search <regexp>` 正向搜索
* `reverse-search <regexp>`  反向搜索
* 其中regexp是正则表达式

#### 指定源文件路径

* 有些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。
* `directory <dirname ... >`  `dir <dirname ... >`   加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，Windows下你可以使用“;”
* `directory`   清除所有的自定义的源文件搜索路径信息。
* `show directories` 显示定义了的源文件搜索路径。

#### 查看源代码的内存

* 使用`info line`命令来查看源代码在内存中的地址。
* 后面可以跟“行号”，“函数名”，“文件名:行号”，“文件名:函数名”，这个命令会打印出所指定的源码在运行时的内存地址

#### 查看机器码

* `disassemble` 你可以查看源程序的当前执行时的机器码
* 后面可跟的参数和info line一样

### 查看栈信息

* 当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。

#### backtrace(bt) 查看函数堆栈

* `backtrace` `bt` 打印当前的函数调用栈的所有信息。
* `backtrace <n>` `bt <n>` n是一个正整数，表示只打印栈顶上n层的栈信息。
* `backtrace <-n>` `bt <-n>` -n表一个负整数，表示只打印栈底下n层的栈信息。

>(gdb) bt  
>#0 func (n=250) at tst.c:6  
>#1 0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30  
>#2 0x400409ed in __libc_start_main () from /lib/libc.so.6  
>从上可以看出函数的调用栈信息：__libc_start_main --> main() --> func()  

#### frame 切换栈

* frame 或 f 会打印出当前栈的信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。
* 如果你要查看某一层的信息，你需要在切换当前的栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。
* `frame <n>`,`f <n>`    n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。  
* `up <n>`    表示向栈的上面移动n层，可以不打n，表示向上移动一层。
* `down <n>`  表示向栈的下面移动n层，可以不打n，表示向下移动一层。
* 上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。可以使用这三个命令
  * `select-frame <n>` 对应于 frame 命令。
  * `up-silently <n>` 对应于 up 命令。
  * `down-silently <n>` 对应于 down 命令。

#### 栈的详细信息

* `info frame`, `info f` 这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。如：

>(gdb) info f  
>Stack level 0, frame at 0xbffff5d4:  
>eip = 0x804845d in func (tst.c:6); saved eip 0x8048524  
>called by frame at 0xbffff60c  
>source language c.  
>Arglist at 0xbffff5d4, args: n=250  
>Locals at 0xbffff5d4, Previous frame's sp is 0x0  
>Saved registers:  
>ebp at 0xbffff5d4, eip at 0xbffff5d8  

* `info args`   打印出当前函数的参数名及其值。
* `info locals` 打印出当前函数中所有局部变量及其值。  
* `info catch`  打印出当前的函数中的异常处理信息。
* `info variables` 打印全局和静态变量

### 查看运行时信息

* 当程序被停住时，可以使用print命令（简写命令为p），或是同义命令inspect来查看当前程序的运行数据。
* print命令的格式是：`print <expr>`，`print /<f> <expr>`
* expr是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），f是输出的格式，
* 可以用whatis 命令可以显示某个变量的类型
* 当你用GDB的print查看程序运行时的数据时，你每一个print都会被GDB记录下来。GDB会以$1, $2, $3 .....这样的方式为你每一个print命令编上号。于是，你可以使用这个编号访问以前的表达式，如$1。这个功能所带来的好处是，如果你先前输入了一个比较长的表达式，如果你还想查看这个表达式的值，你可以使用历史记录来访问，省去了重复输入。

#### 数据输出的可选格式

* 使用时用/跟在命令的后面，例如`p/c buf`,以字符格式打印buf的内容
* 可用的命令包括有

|选项|格式|说明|
|:---:|:-----:|:-----:|
a|address|按十六进制格式显示地址，并显示距离前继符号的偏移量(offset)。常用于定位未知地址(变量)
c|character| 按字符格式显示变量。
d|signed decimal|按十进制格式显示变量。
f|floating| 按浮点数格式显示变量。
i||显示为机器语言（仅在显示内存的x命令中可用）
o|octal| 按八进制格式显示变量。
s|string| 显示为字符串
t|binary| 按二进制格式显示变量。
u|unsigned decimal| 按十进制格式显示无符号整型。
x|hexadecimal| 按十六进制格式显示变量。

#### 查看程序变量

* 可以随时查看以下三种变量的值：
  1. 全局变量（所有文件可见的）
  2. 静态全局变量（当前文件可见的）
  3. 局部变量（当前Scope可见的） 
* 如果局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量,如果此时你想查看全局变量的值时，你可以使用“::”操作符：例如`file::variable`，`function::variable`
* 如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在GDB调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化

#### 查看数组

* 使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边则是想查看内存的长度
* 是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。

>例如，你的程序中有这样的语句：int *array = (int*) malloc (len*sizeof (int));  
>在GDB调试过程中，可以用如下命令显示出这个动态数组的取值:p*array@len  

#### 查看指定内存地址内容

* 可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：`x /<n/f/u>  <addr>`
* 其中，n、f、u是可选的参数。addr表示待查看的内存地址。
* n: 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址（units）的内容。
* f: 表示显示的格式（format），默认初始使用十六进制格式。
* u: 表示（the unit size）从当前地址往后请求的位宽大小。如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了位宽长度后，GDB会从指内存定的内存地址开始，读写指定位宽大小，并把其当作一个值取出来

> 例如命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。

#### 自动显示

* 可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display
* `display <expr>`，`display/<fmt> <expr>`,`display/<fmt> <addr>`
* expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。
* `undisplay <dnums...>`,`delete display <dnums...>` 删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）
* `disable display <dnums...>`  `enable display <dnums...>`  disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。
* `info display` 查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。

#### 设置显示选项

* `set print address on`  打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的
* `set print address off` 关闭函数的参数地址显示
* `show print address` 查看当前地址显示选项是否打开。
* `set print array on` 打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗号分隔。这个选项默认是关闭的。
* `set print array off`
* `show print array`
* `set print elements <number-of-elements>`  这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个number-of-elements来指定数据显示的最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。
* `show print elements`  查看print elements的选项信息
* `set print null-stop <on/off>` 如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。
* `set print pretty on` 如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。
* `set print pretty off` 关闭printf pretty这个选项
* `show print pretty`  查看GDB是如何显示结构体的
* `set print sevenbit-strings <on/off>`   设置字符显示，是否按“/nnn”的格式显示，如果打开，则字符串或字符数据按/nnn显示，如“/065”。 * `show print sevenbit-strings`    查看字符显示开关是否打开。
* `set print union <on/off>`  设置显示结构体时，是否显式其内的联合体数据。
* `show print union` 查看联合体数据的显示方式
* `set print object <on/off>`  在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。
* `show print object` 查看对象选项的设置。
* `set print static-members <on/off>` 这个选项表示，当显示一个C++对象中的内容时，是否显示其中的静态数据成员。默认是on。
* `show print static-members` 查看静态数据成员选项设置。
* `set print vtbl <on/off>` 当此选项打开时，GDB将用比较规整的格式来显示虚函数表时。其默认是关闭的。
* `show print vtbl` 查看虚函数显示格式的选项。

#### 查看寄存器的值

* 寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈地址（sp）等等
* `info registers` 查看寄存器的情况。（除了浮点寄存器）
* `info all-registers` 查看所有寄存器的情况。（包括浮点寄存器）
* `info registers <regname ...>` 查看所指定的寄存器的情况
* 同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：p $eip。

#### 使用环境变量

* 可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。要定义一个GDB的变量很简单只需。使用GDB的set命令。GDB的环境变量和UNIX一样，也是以$起头
* `set $foo = *object_ptr`使用环境变量时，GDB会在你第一次使用时创建这个变量，而在以后的使用中，则直接对其賦值。环境变量没有类型，你可以给环境变量定义任一的类型。包括结构体和数组。
* `show convenience` 该命令查看当前所设置的所有的环境变量。

> 环境变量和程序变量的交互使用，将使得程序调试更为灵活便捷。  
> 例如：   set $i = 0        print bar[$i++]->contents  
> 于是，不必，print bar[0]->contents, print bar[1]->contents地输入命令了。输入这样的命令后，只用敲回车，重复执行上一条语句，环境变量会自动累加，从而完成逐个输出的功能。  

### 改变程序的执行

#### 修改变量值

* 修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成，例如`(gdb) print x=4`
* 最好还是使用set var命令

#### 跳转执行

* 一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的jump命令来完
* `jump <linespec>`  指定下一条语句的运行点。linespce可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。
* `jump <address>`   这里的address是代码行的内存地址。
* 注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常奇怪的，甚至于产生程序Core Dump。所以最好是同一个函数中进行跳转。
* 熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行的地址。如：`set $pc = 0x485`

#### 产生信号量

* 使用singal命令，可以产生一个信号量给被调试的程序
* 可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。
* `signal <singal>` UNIX的系统信号量通常从1到15。所以singal取值也在这个范围。
* single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。

#### 强制函数返回

* 如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数忽略还没有执行的语句并返回。
* `return <expression>`    使用return命令取消当前函数的执行，并立即返回，如果指定了expression，那么该表达式的值会被认作函数的返回值。

#### 强制调用函数

* `call <expr>`  表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。
* 另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返回值，并把该值存入历史数据中。

## 多线程调试

- 线程产生通知：在产生新的线程时, gdb会给出提示信息
- 查看线程：使用info threads可以查看运行的线程。
  - 行首的数字为gdb分配的线程号，对线程进行切换时，使用该号码
  - 行首的星号标识了当前活动的线程
- 切换线程：使用`thread THREADNUMBER`进行切换，THREADNUMBER 为上文提到的线程号
- 控制线程的运行
  - `set scheduler-locking off`	不锁定任何线程，也就是所有线程都执行，这是默认值
  - `set scheduler-locking on`	只有当前被调试程序会执行
  - `set scheduler-locking step`：阻止其他线程在当前线程单步调试时，抢占当前线程。只有当next、continue、util以及finish的时候，其他线程才会获得重新运行的机会。



break thread_test.c:123 thread all（例：在相应函数的位置设置断点break pthread_run1）	在所有线程中相应的行上设置断点
thread apply ID1 ID2 command	让一个或者多个线程执行GDB命令command
thread apply all command	让所有被调试线程执行GDB命令command
set scheduler-locking 选项 command	设置线程是以什么方式来执行命令

set scheduler-locking on step	在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行



### 常用命令汇总

- 直接回车表示重复上一次命令
- 输入命令时，可以不用打全命令，只用打命令的前几个字符就可以了，当然，命令的前几个字符应该要标志着一个唯一的命令
- 可以敲击两次TAB键来补齐命令的全称，如果有重复的，那么gdb会把其例出来。

|命令|命令缩写|简单说明|具体说明
|:---:|:-----:|:-----:|:-----:|
backtrace|bt|查看函数调用信息(堆栈)
break|b|设置断点,程序运行到断点的位置会停下来|[断点](#断点（BreakPoint)
catch||设置捕捉点，补捉程序运行时的一些事件|[捕捉点](#捕捉点（CatchPoint）)
continue|c|继续程序的运行,直到遇到下一个断点
display|disp|跟踪查看某个变量,每次停下来都显示它的值
file||装入需要调试的程序|
frame|f|查看栈帧
info|i|描述程序的状态|
kill|k|终止正在调试的程序
list|l|显示多行源代码|
next|n|执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)
print|p|打印内部变量值|[print](#print)
quit|q|退出GDB环境
run|r|开始运行程序|
set var name=v||设置变量的值
start|st|开始执行程序,在main函数的第一条语句前面停下来
step|s|执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句
watch||监视变量值的变化,使用观察点可以使得当某表达式的值发生变化时,程序暂停执行|[观察点](#观察点（WatchPoint))
whatis 变量名||查看变量的类型
