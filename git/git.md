
- [1. 简介](#1-简介)
  - [1.1 集中式vs分布式](#11-集中式vs分布式)
  - [1.2 Git特点](#12-git特点)
  - [1.3 Git的四大工作区域](#13-git的四大工作区域)
  - [1.4 Git中文件的四种状态](#14-git中文件的四种状态)
  - [1.4 Git工作流程](#14-git工作流程)
- [2. 安装和使用前配置](#2-安装和使用前配置)
  - [1. 从源代码安装](#1-从源代码安装)
  - [2. 用系统提供的包管理工具](#2-用系统提供的包管理工具)
  - [3. 配置](#3-配置)
- [3. git本地操作](#3-git本地操作)
  - [1. 初始化新仓库, git init](#1-初始化新仓库-git-init)
  - [2. 克隆现有仓库, git clone](#2-克隆现有仓库-git-clone)
  - [3. 文件信息, git status](#3-文件信息-git-status)
  - [4. 跟踪和暂存文件, git add](#4-跟踪和暂存文件-git-add)
  - [5. 取消暂存的文件,回退版本 git reset/git revert](#5-取消暂存的文件回退版本-git-resetgit-revert)
  - [6. 取消对文件的修改, git checkout](#6-取消对文件的修改-git-checkout)
  - [7. 查看已暂存和未暂存的更新，git diff](#7-查看已暂存和未暂存的更新git-diff)
  - [8. 提交更新，git commit](#8-提交更新git-commit)
  - [9. 移除文件，git rm](#9-移除文件git-rm)
  - [10. 移动文件, git mv](#10-移动文件-git-mv)
  - [11.查看提交历史， git log](#11查看提交历史-git-log)
  - [12. 查看历史命令, git reflog](#12-查看历史命令-git-reflog)
  - [12. 标签，git tag](#12-标签git-tag)
  - [13. 忽略部分文件](#13-忽略部分文件)
- [4. Git远程操作](#4-git远程操作)
  - [1. 查看当前的远程库, git remote](#1-查看当前的远程库-git-remote)
  - [2. 从远程仓库抓取数据, git fetch](#2-从远程仓库抓取数据-git-fetch)
  - [3. 推送数据到远程仓库, git push](#3-推送数据到远程仓库-git-push)
- [5. Git分支管理](#5-git分支管理)
  - [1. 分支简介](#1-分支简介)
  - [2. 新建与合并分支](#2-新建与合并分支)
  - [3. 切换分支](#3-切换分支)
  - [4. 合并分支, git merge](#4-合并分支-git-merge)
  - [5. 衍合分支，git rebase](#5-衍合分支git-rebase)
  - [5. 远程分支](#5-远程分支)
- [6. github的使用](#6-github的使用)
  - [1. 绑定github账号](#1-绑定github账号)
  - [2. 先有本地库，关联远程库](#2-先有本地库关联远程库)
  - [3. 先有远程库，克隆到本地](#3-先有远程库克隆到本地)


[参考资料](https://www.liaoxuefeng.com/wiki/896043488029600)
[参考资料](http://shouce.jb51.net/gitbook/Getting-Started/About-Version-Control.html)


# 1. 简介

- Git是分布式版本控制系统

## 1.1 集中式vs分布式
- 版本控制系统
  - 一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统
- 集中式
  - 有一个集中管理的中央服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新
  - 每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易
  - 必须联网才能工作，中央服务器的单点故障造成的损失大
- 分布式
  - 没有“中央服务器”，每个人的电脑上都是一个完整的版本库
  - 客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份
  - 优点
    - 用户在本地就可以查看所有的历史版本信息，但是偶尔要从远程更新一下，因为可能别的用户有文件修改提交到远程哦。
    - 用户即使离线也可以本地提交，push推送到远程服务器才需要联网。
    - 每个用户都保存了历史版本，所以只要有一个用户设备没问题，就可以恢复数据啦

## 1.2 Git特点
- 直接记录快照，而非差异比较。Git 保存的不是文件差异或者变化量，而只是一系列文件快照
- 绝大多数操作都只需要访问本地文件和资源，不用连网。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新。
- 时刻保持数据完整性。使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。
- 高可靠性，不会弄丢数据

## 1.3 Git的四大工作区域

1. __Workspace__：你电脑本地看到的文件和目录，在Git的版本控制下，构成了工作区。
2. __Index/Stage__：暂存区，一般存放在 .git目录下，即.git/index,它又叫待提交更新区，用于临时存放你未提交的改动。比如，你执行git add，这些改动就添加到这个区域啦。
3. __Repository__：本地仓库，你执行git clone 地址，就是把远程仓库克隆到本地仓库。它是一个存放在本地的版本库，其中HEAD指向最新放入仓库的版本。当你执行git commit，文件改动就到本地仓库来了~
4. __Remote__：远程仓库，就是类似github，码云等网站所提供的仓库，可以理解为远程数据交换的仓库

## 1.4 Git中文件的四种状态

1. __未跟踪(Untracked)__, 文件还没有加入到git库，还没参与版本控制。通过git add可以变为Staged状态
2. __未修改(Unmodified)__, 文件已经加入git库, 但是还没修改.
3. __已修改（modified）__, 表示修改了某个文件，但还没有提交保存
4. __已暂存（staged）__, 把已修改的文件放在下次提交时要保存的清单中
5. __已提交（committed）__, 表示该文件已经被安全地保存在本地数据库中了



## 1.4 Git工作流程
1. 在工作目录中修改某些文件。已修改
2. 对修改后的文件进行快照，然后保存到暂存区域。已暂存
3. 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。已提交
   
# 2. 安装和使用前配置

## 1. 从源代码安装
- 先从官网下载最新的版本源代码，https://git-scm.com/download/linux。
  - ` wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.9.5.tar.gz`,从服务器下载文件到当前目录，也可以加上-O指定目标文件夹，并且修改文件名称
- 随后解压缩并安装
- 可以安装最新的版本，因为有些 Linux 版本自带的安装包更新起来并不及时
```bash
tar -zxf git-2.9.5.tar.gz
cd git-1.7.2.2
make prefix=/usr/local all
sudo make prefix=/usr/local install
```
## 2. 用系统提供的包管理工具
```bash
yum install git-core
apt-get install git
```

## 3. 配置
- 三个地方存在着git的配置文件
  - /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。
  - ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。
  - 当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。
- 配置用户信息
 
```bash
# 配置的个人的用户名称和电子邮件地址
# 用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里
git config --global user.name "John Doe"
git config --global user.email johndoe@example.com
# 设置使用的文本编辑器,默认编辑器一般可能会是 Vi 或者 Vim，用默认的就行了
git config --global core.editor emacs
# 设置差异分析工具，用默认的就行了
git config --global merge.tool vimdiff
# 查看配置信息
git config –list
git config <特定配置>
```

# 3. git本地操作

## 1. 初始化新仓库, git init

- 对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行`git init`
- 初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中
```bash
mkdir newdir
cd newdir
git init
```

## 2. 克隆现有仓库, git clone

- `git clone [url]`
- 也可以在克隆的时候，自己定义要新建的项目目录名称`git clone [url] [newname]`
- 在当前目录下创建一个名为 “克隆的项目名” 的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。如果进入这个新建的 grit 目录，你会看到项目中的所有文件已经在里边了，准备好后续的开发和使用

## 3. 文件信息, git status
- `git status`
- 在 **Changes to be committed** 这行下面的文件，就说明是已暂存状态
- 在 **Changes not staged for commit** 这行下面的文件，说明已跟踪文件的内容发生了变化，但还没有放到暂存区，也就是已修改状态

## 4. 跟踪和暂存文件, git add
- 已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区
- `git add 文件或目录`, 是目录的话，就说明要递归该目录下的所有文件
- git add是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等
- git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area ，同时未曾跟踪过的文件标记为需要跟踪

## 5. 取消暂存的文件,回退版本 git reset/git revert
- `git reset HEAD <file>`, 把文件从暂存区中退出来
- `git reset --hard [commit_id]`,彻底回退到某个版本，本地的源码也会变为上一个版本的内容
  - commit_id可以用HEAD表示，HEAD指向的版本就是当前版本，HEAD^表示上一个版本，HEAD^^表示上上个版本，HEAD~n表示往上n个版本
  - 版本号没必要写全，前几位就可以了
  - 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
  - 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。
- `git reset --soft [commit_id]`，回退到某个版本，只回退了commit的信息，文件还在暂存区
- `git revert [commit_id]`,“反做”某一个版本，以达到撤销该版本的修改的目的
- git reset和git revert的区别
  - revert 是回滚某个 commit ，不是回滚“到”某个commit，会生成一个新的版本，而reset是回到前面的版本
  
  https://blog.csdn.net/asoar/article/details/84111841?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param
  
## 6. 取消对文件的修改, git checkout
- `git checkout -- <file>`
- file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
- file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
- 总之，就是让file回到最近一次git commit或git add时的状态。

- 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- <file>`
- 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD <file>`，就回到了场景1，第二步按场景1操作。
- 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。

## 7. 查看已暂存和未暂存的更新，git diff

- 查看尚未暂存的文件更新了哪些部分，不加参数直接输入`git diff`,比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容
- 查看已经暂存起来的文件和上次提交时的快照之间的差异，可以用`git diff --cached`或`git diff --staged`命令

## 8. 提交更新，git commit

- `git commit -m <说明>`
- 提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态
- 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较
- 提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添改和删改过。
- `git commit -a`, 自动把所有已经跟踪过的文件暂存起来一并提交，跳过 git add 步骤
- `git commit --amend`，重新提交，会覆盖上一次的提交,但gitlog显示的提交时间还是上一次的，只改变文件内容
- 在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。

## 9. 移除文件，git rm

- `git rm file`，从已跟踪文件清单中移除（确切地说，是从暂存区域移除）该文件，最后还需git commmit提交
- `git rm -f file`，如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容
- `git rm --cached file`,把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除
- 要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交
  
## 10. 移动文件, git mv

- `git mv oldname newname`

## 11.查看提交历史， git log
- 默认输出会按提交时间列出所有的更新，最近的更新排在最上面，每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。
- -p, 展开显示每次提交的内容差异
- -stat，仅显示简要的增改行数统计
- -< n >, 显示最近的n次更新
- -graph，开头会多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况
- --pretty=oneline， --pretty=short, --pretty=full, --pretty=fuller
- --pretty=format:"格式", 可以定制要显示的记录格式,常用的格式占位符如下
  
选项|说明
|--|--|
%H|提交对象（commit）的完整哈希字串
%h|提交对象的简短哈希字串
%T|树对象（tree）的完整哈希字串
%t|树对象的简短哈希字串
%P|父对象（parent）的完整哈希字串
%p|父对象的简短哈希字串
%an|作者（author）的名字
%ae|作者的电子邮件地址
%ad|作者修订日期（可以用 -date= 选项定制格式）
%ar|作者修订日期，按多久以前的方式显示
%cn|提交者(committer)的名字
%ce|提交者的电子邮件地址
%cd|提交日期
%cr|提交日期，按多久以前的方式显示
%s|提交说明

## 12. 查看历史命令, git reflog

- `git reflog`
  
## 12. 标签，git tag
- 两种类型的标签
  - 轻量级的（lightweight），像是个不会变化的分支，实际上它就是个指向特定提交对象的引用
  - 含附注的（annotated），是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证
- `git tag`, 列出现有标签
- `git tag [tagname]`, 创建一个轻量级标签
- `git tag -a [tagname] -m [message]`, 创建一个含附注类型的标签
- `git tag -s [tagname] -m [message]`, 签署标签, 如果你有自己的私钥，还可以用 GPG 来签署标签
- `git tag -v [tag-name]`, 验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证
- `git show [tagname]`, 查看相应标签的版本信息，并连同显示打标签时的提交对
- `git tag [checksum]`, 可以在后期对早先的某次提交加注标签,只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）

## 13. 忽略部分文件

- 一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等
- 可以在当前目录下创建一个名为 .gitignore 的文件，列出要忽略的文件模式
- 文件 .gitignore 的格式规范如下：
  - 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。
  - 可以使用标准的 glob (简化了的正则表达式)模式匹配。
    - 星号(*)匹配零个或多个任意字符
    - [abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）
    - 问号（?）只匹配一个任意字符
    - 如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）
    - 使用两个星号（*) 表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z , a/b/z 或 a/b/c/z 等
  - 匹配模式最后跟反斜杠（/）说明要忽略的是目录。
  - 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反
```
# 此为注释 – 将被 Git 忽略
*.a       # 忽略所有 .a 结尾的文件
!lib.a    # 但 lib.a 除外
/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
build/    # 忽略 build/ 目录下的所有文件
doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
```


# 4. Git远程操作

- 远程仓库是指托管在网络上的项目仓库，可能会有好多个，其中有些你只能读，另外有些可以写。同他人协作开发某个项目时，需要管理这些远程仓库，以便推送或拉取数据，分享各自的工作进展
- 管理远程仓库的工作，包括添加远程库，移除废弃的远程库，管理各式远程库分支，定义是否跟踪这些分支
  
## 1. 查看当前的远程库, git remote
- `git remote`, 查看当前配置有哪些远程仓库,会列出每个远程库的简短名字,在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库
- `git remote -v`: 显示对应的克隆地址
- `git remote add [shortname] [url]`, 添加一个新的远程仓库，可以同时指定一个简单的名字，以便将来引用
- `git remote rename [oldname] [newname]`, 修改某个远程仓库在本地的简短名称
- `git remote show [remote-name]`, 查看某个远程仓库的详细信息
- `git remote rm [remote-name]`, 移除对应的远端仓库



* 查看远程库信息，使用git remote -v；
* 本地新建的分支如果不推送到远程，对其他人就是不可见的；
* 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；
* 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；
* 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；
* 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。


## 2. 从远程仓库抓取数据, git fetch
- `git fetch [remote-name]`
- 会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟
- fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并

- [参考资料](https://www.cnblogs.com/runnerjack/p/9342362.html)
- git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。
- git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。
  
## 3. 推送数据到远程仓库, git push
- `git push [remote-name] [branch-name]`
- `git push [remote-name] [tag-name]`,分享标签到远端仓库
- `git push [remote-name] --tags`,一次推送所有本地新增的标签上去
- 只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。
- 如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送

如果设置了某个分支用于跟踪某个远端仓库的分支（参见下节及第三章的内容），可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支

- 如果本地库HEAD指向的版本比远程库的要旧，git push会失败，需要用`git push -f`强制推上去

# 5. Git分支管理

## 1. 分支简介
- 使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作
- Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快
- 在 Git 中提交时，会保存一个**提交（commit）对象**，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。
  
## 2. 新建与合并分支

- `git branch`，查看分支,给出当前所有分支的清单,*字符表示当前所在的分支
- `git branch -v`, 查看各个分支最后一个提交对象的信息
- `git branch [name]`，创建分支，会在当前 commit 对象上新建一个分支指针，但不会自动切换到这个分支中去
- `git branch -d [name]`, 删除分支,删除未合并进来的分支会提示错误
- `git branch -D [name]`, 强行删除,丢弃一个没有被合并过的分支
- **HEAD指针**, 指向正在工作中的本地分支的指针，每次提交后 HEAD 随着分支一起向前移动
- `git branch -merge`, 查看哪些分支已被并入当前分支（译注::也就是说哪些分支是当前分支的直接上游。
- `git branch -no-merged`,  查看尚未合并的工作


## 3. 切换分支
- ` git checkout [name]`,会让HEAD指向name分支,或者`git switch [name]`
- ` git checkout -b [name]`或者`git switch -c [name]`, 新建并切换到该分支，相当于同时执行了git branch和git checkout
- 切换分支时会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。


## 4. 合并分支, git merge

- `git merge [name]`, 合并某分支到当前分支
- **快进（Fast forward）合并**，如果当前分支是要并入的分支的直接上游，Git 只需把当前分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧
- 如果当前分支是要并入的分支的直接下游，会提示Already up to date，没有什么变化
- 遇到冲突时的分支合并, 如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起
  - 执行git merge后，Git 作了合并，但没有提交，会停下来等你解决冲突
  - 用 git status 查阅哪些文件在合并时发生冲突,任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出
  - Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突,======= 隔开的上半部分，是 HEAD中的内容，下半部分是在要合并的分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起
  - 在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注::实际上就是来一次快照保存到暂存区域。
  - 如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交
  - 最终结果是会把两个分支最新的快照（C3 和 C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）
- 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。

* git stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作
* 是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；
* 另一种方式是用git stash pop，恢复的同时把stash内容也删了：
* 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动

```
               |------C3-----|
C0<----C1<----C2              ------C5
               |------C4-----| 

```

## 5. 衍合分支，git rebase
- [参考资料](https://blog.csdn.net/wh_19910525/article/details/7554489)
- [参考资料](https://www.cnblogs.com/shuimuzhushui/p/9000253.html)
- git merge：将两个分支，合并提交为一个新提交，并且新提交有2个parent。C5 parent为C3和C4
- git rebase：会取消分支中的每个提交，并把他们临时存放，然后把当前分支更新到最新的origin分支，最后再吧所有提交应用到分支上。
- `git rebase [主分支] [特性分支]`,  


- rebase会把你当前分支的 commit 放到公共分支的最后面,所以叫变基。就好像你从公共分支又重新拉出来这个分支一样。
merge 会把公共分支和你当前的commit 合并在一起，形成一个新的 commit 提交
- 不要在公共分支使用rebase

## 5. 远程分支














# 6. github的使用

## 1. 绑定github账号
1. 创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到第三步。如果没有，进入第二步
2. 打开Shell（Windows下打开Git Bash），创建SSH Key `$ ssh-keygen -t rsa -C "youremail@example.com"`
3. 在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，id_rsa.pub是公钥
4. 登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容

## 2. 先有本地库，关联远程库

要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；

关联后，使用命令git push -u origin master第一次推送master分支的所有内容；

此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；

## 3. 先有远程库，克隆到本地

要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。

Git支持多种协议，包括https，但ssh协议速度最快。