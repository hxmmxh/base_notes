Linux
-------------------------------------------------

- [一. 用户管理](#一-用户管理)
  - [1. 用户和用户组概念](#1-用户和用户组概念)
  - [2. 创建和删除用户](#2-创建和删除用户)
  - [3. 切换用户](#3-切换用户)
- [二. 文件管理](#二-文件管理)
  - [1. 目录结构](#1-目录结构)
  - [2. 路径](#2-路径)
  - [3. 权限](#3-权限)
  - [4. 目录操作](#4-目录操作)
  - [5. 文件操作](#5-文件操作)
    - [1. 创建和删除文件](#1-创建和删除文件)
    - [2. 查看文件](#2-查看文件)
    - [3. 查找文件](#3-查找文件)
    - [4. 压缩和打包文件](#4-压缩和打包文件)
    - [5. 下载文件](#5-下载文件)
- [三. 文本处理](#三-文本处理)
  - [1. 正则表达式](#1-正则表达式)
    - [1. 元字符](#1-元字符)
    - [2. 通配符](#2-通配符)
  - [2. 使用grep搜索文本](#2-使用grep搜索文本)
  - [3. 使用sort排序](#3-使用sort排序)
  - [4. 使用uniq删除重复内容](#4-使用uniq删除重复内容)
  - [5. 使用cut切分文本](#5-使用cut切分文本)
  - [6. 使用tr做文本转换](#6-使用tr做文本转换)
  - [7. 使用paste拼接文本](#7-使用paste拼接文本)
  - [8. 使用split分割大文件](#8-使用split分割大文件)
  - [9. 统计：wc](#9-统计wc)
  - [10. 文本处理工具sed](#10-文本处理工具sed)
  - [11. 文本处理工具awk](#11-文本处理工具awk)
- [三，输入与输出](#三输入与输出)
  - [1.标准输出和输入](#1标准输出和输入)
  - [1. 重定向](#1-重定向)
  - [3. 管道](#3-管道)
- [三.进程管理](#三进程管理)
  - [1.进程查询：ps](#1进程查询ps)
      - [示例](#示例)
  - [2.进程监控：top](#2进程监控top)
      - [使用方法](#使用方法)
  - [3. 例行任务管理](#3-例行任务管理)
  - [3.打开文件查询：lsof](#3打开文件查询lsof)
      - [使用方法](#使用方法-1)
  - [4.内存使用量：free](#4内存使用量free)
      - [使用方法](#使用方法-2)
  - [5.shell进程的资源限制：ulimit](#5shell进程的资源限制ulimit)
      - [使用方法](#使用方法-3)
      - [示例](#示例-1)
- [四.网络工具](#四网络工具)
  - [1.网卡配置：ifconfig](#1网卡配置ifconfig)
  - [2.查看当前网络连接：netstat](#2查看当前网络连接netstat)
  - [3.查看路由表：route](#3查看路由表route)
  - [4.检查网络连通性：ping](#4检查网络连通性ping)
  - [5.转发路径：traceroute](#5转发路径traceroute)
  - [6.网络Debug分析：nc](#6网络debug分析nc)
  - [7.命令行抓包：tcpdump](#7命令行抓包tcpdump)
      - [使用方法](#使用方法-4)
      - [示例](#示例-2)
  - [8.域名解析工具：dig](#8域名解析工具dig)
  - [9.网络请求：curl](#9网络请求curl)
- [五.开发及调试](#五开发及调试)
  - [1.编辑器：vim](#1编辑器vim)
  - [2.编译器：gcc和g++](#2编译器gcc和g)
      - [使用方法](#使用方法-5)
  - [3.调试工具：gdb](#3调试工具gdb)
      - [使用方法](#使用方法-6)
  - [4.查看依赖库：ldd](#4查看依赖库ldd)
  - [5.二进制文件分析：objdump](#5二进制文件分析objdump)
  - [6.ELF文件格式分析：readelf](#6elf文件格式分析readelf)
  - [7.跟踪进程中系统调用：strace](#7跟踪进程中系统调用strace)
  - [8.跟踪进程栈：pstack](#8跟踪进程栈pstack)
  - [9.进程内存映射：pmap](#9进程内存映射pmap)
- [六.其他](#六其他)
  - [1.终止进程：kill](#1终止进程kill)
  - [2.修改文件权限：chmod](#2修改文件权限chmod)
      - [使用方法](#使用方法-7)
  - [3.创建链接：ln](#3创建链接ln)
  - [4.显示文件尾：tail](#4显示文件尾tail)
  - [5.版本控制：git](#5版本控制git)
  - [6.设置别名：alias](#6设置别名alias)

# 一. 用户管理

## 1. 用户和用户组概念
- Linux系统采用一个32位的整数记录和区分不同的用户，这个用来区分不同用户的数字被称为User ID，简称UID
- Linux系统中的用户分为3类，即普通用户、根用户、系统用户
  - 普通用户是指所有使用Linux系统的真实用户，通常普通用户的UID大于500，因为在添加普通用户时，系统默认用户ID从500开始
  - 根用户也就是root用户，它的ID是0，也被称为超级用户，root账户拥有对系统的完全控制权：可以修改、删除任何文件，运行任何命令
  - 系统用户是指系统运行时必须有的用户，但并不是指真实的使用者,系统用户的ID范围是1~499
## 2. 创建和删除用户
```bash
#1. 创建用户
useradd hxm
可选操作：
    -m:当/etc/login.defs中的CREATE_HOME被设置为no时，只有加上-m才会创建用户主目录
    -u:指定UID
    -g:指定GID
    -d:指定该用户的家目录
# 建议使用更加友好的adduser去完成添加用户的工作
adduser hxm

#2. 设置密码
passwd hxm

#3. 删除用户
userdel hxm

#4. 修改用户信息
usermode
可选操作：
  -c<备注> 　修改用户帐号的备注文字。
　-d<登入目录> 　修改用户登入时的目录。
　-e<有效期限> 　修改帐号的有效期限。
　-f<缓冲天数> 　修改在密码过期后多少天即关闭该帐号。
　-g<群组> 　修改用户所属的群组。
　-G<群组> 　修改用户所属的附加群组。
　-l<帐号名称> 　修改用户帐号名称。
　-L 　锁定用户密码，使密码无效。
　-s<shell> 　修改用户登入后所使用的shell。
　-u<uid> 　修改用户ID。
　-U 　解除密码锁定。
#5.获得自己的UID,结果为uid=1000(hxm) gid=1000(hxm) groups=1000(hxm)
id
#6.获得自己所处的用户组,结果为hxm
groups
#7.查询当前在线用户信息
users或者who或者w，给出的信息越来越详细
finger <用户名>
#8. 添加和删除用户组
groupadd
groupdel
```
- 添加新用户时系统完成的操作
  - 系统需要将用户信息记录在/etc/passwd中，一般会在/etc/passwd和/etc/shadow末尾追加一条记录，同时会分配给该用户一个UID
    >目前Linux的做法是，将密码相关的信息保存到/etc/shadow中，而且默认只有root用户才有读的权限，其他人完全没有读取这个文件的可能。这种密码保存方式被称为“影子密码
  - 要为该用户自动创建家目录。家目录以创建的用户名为目录名，创建的路径在/home目录中。比如，在上述案例中，创建的目录将是/home/hxm
  - 新建一个与该用户名一样的用户组，也就是说当创建用户john的时候，也同时创建了一个叫john的用户组，而用户john默认属于john用户
- 创建用户后，该用户实际上还没有登录系统的权限，因为在不设置密码的情况下，在/etc/shadow中该用户记录中以冒号分隔的第二列将显示为两个感叹号“！！”，这说明不允许该用户登录系统

## 3. 切换用户
- su命令
  - su是切换用户的意思。在不加参数的情况下，su命令默认表示切换到root用户，之后只要输入root密码就可以切换身份为root了，完成操作后，使用exit命令可以退出root切换到原先的用户
  - su命令后面还可以加上一个“-”参数，就是键盘上的中横线。加上这个参数后，切换成root用户时，不但身份变成了root，而且还能应用root的用户环境。所谓“用户环境”就是/etc/passwd中定义的用户家目录、使用的Shell，以及关于这个用户的个性化设置等
  - su-命令后还可以继续跟其他的用户名作为参数，这样就可以切换成指定用户的身份，root用户可以使用su命令切换成任意用户而不需要密码
  - 明显的缺陷，就是切换成其他用户的前提是需要知道对方的密码
- sudo命令
  - 在sudo后跟上需要执行的命令，运行该命令时，系统首先检查/etc/sudoers，判断该用户是否有执行sudo的权限，在确定有执行权限后，系统要求用户输自己的密码，如果密码输入正确，则会以root用户的身份运行passwd user1命令。
  - 可以使用专门的命令visudo来编辑/etc/sudoers
  - 严格来说，sudo并不是真的切换了用户，而是使用其他用户的身份和权限执行了命令。



# 二. 文件管理

## 1. 目录结构
- Linux目录类似一个树，最顶层是其根目录"/"，FHS（文件系统层次标准）定义了在根目录下的主要目录以及每个目录应该存放什么文件
  - /bin：存放二进制可执行文件，常用命令一般都在这里。
  - /sbin：存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。
  - /etc：存放系统管理和配置文件
  - /home：存放普通用户文件的根目录
  - /opt： 额外安装的可选应用程序包所放置的位置。
  - /proc：虚拟文件系统目录
  - /root：超级用户（系统管理员）的主目录
  - /dev：用于存放设备文件。
  - /boot：存放用于系统引导时使用的各种文件
  - /tmp：用于存放各种临时文件
  - /mnt: 加载文件系统时常用的挂载点
  - /lib：存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。
  - /var：用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。
  - /lost+found：这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里
  - /usr：存放与用户直接相关的文件和目录
    - /usr/x11r6 存放x window的目录
    - /usr/bin 众多的应用程序  
    - /usr/sbin 超级用户的一些管理程序 
    - /usr/doc linux文档  
    - /usr/include linux下开发和编译应用程序所需要的头文件  
    - /usr/lib 常用的动态链接库和软件包的配置文件  
    - /usr/man 帮助文档  
    - /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里  
    - /usr/local/bin 本地增加的命令  
    - /usr/local/lib 本地增加的库

## 2. 路径
- 绝对路径：从根目录开始的全路径被称为“绝对路径”，绝对路径一定是以“/”开头的
- 相对路径
- 一个点（.）代表的是当前目录，两个点（..）代表的是当前目录的上层目录

## 3. 权限

## 4. 目录操作
```bash
# 查看当前所在目录
pwd
# 进入目录
cd
# 创建目录
mkdir
# 删除目录
rmdir #只能删除空目录，如果目录不为空（存在文件或者子目录），那么该命令将拒绝删除指定的目录
rm -r 
# 查看目录下的文件
ls
    -l:要求ls命令列出每个文件的详细信息
    -a:要求ls命令还要同时列出隐藏文件
```
## 5. 文件操作
### 1. 创建和删除文件
```bash
# 创建文件，如果文件已经存在，那么touch命令仅仅会更新文件的创建时间而不会修改文件内容
touch
# 删除文件
rm
# 移动和重命名文件和目录
mv <文件> <移动到的目录或文件名>
# 复制文件
cp [-a,-i,-r] <文件> <移动到的目录或文件名>
选项：
    -a：将所有属性一起复制（包括拥有者、时间等信息）
    -i：目标文件存在时，进行询问
    -r：递归复制
```

### 2. 查看文件
```bash
# 查看文件
cat 
# 查看文件，显示行号
nl
# 查看文件头，默认情况下d将显示该文件前10行的内容
head
# 查看文件尾，默认情况下d将显示该文件前10行的内容
tail
# 把DOS格式的文本文件转变成UNIX下的文本文件,当把Windows下的文本文件移动到Linux下时，会由于系统之间文本文件的换行符不同而造成文件在Linux下的读写操作有问题
dos2unix
# 以各种格式输出文件内容
od
```
### 3. 查找文件

```bash
find [查找目录] [查找条件]

查找目录：
    .：在当前目录及子目录下查找（默认）
    A：在目录A及A的子目录下查找
查找条件：
    -name：根据文件名查找
    -regex：使用正则表达式匹配
    -type：按类型查找（f:文件，d:目录，l:链接...）
    -atime：按访问时间查找（n:n天前的一天内，+n:n天前(不含n天本身)，-n:n天内(不含n天)）
    -mtime：按修改时间查找（n:n天前的一天内，+n:n天前(不含n天本身)，-n:n天内(不含n天)）
    -size：按大小查找（单位k，+nk:"比nk更大"，-nk:"比nk更小"）
    -perm：按权限查找（644：权限等于644的文件）
    -user/-nouser：用户名等于/用户名不等于
    -group/-nogroup：组名等于/组名不等于
```

### 4. 压缩和打包文件



```bash
tar [-j|-z] [cv] [-f 压缩包名] 目录
tar [-j|-z] [xv] [-f 解压包名] [-C 解压路径]

选项：
    -c/-x：打包/解包
    -j/-z：bzip2格式/gzip格式
    -v：显示过程
```

### 5. 下载文件
- wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用.
```bash
# 使用wget下载单个文件.
wget URL
#下载并以不同的文件名保存.
wget -O filename URL
# 将文件保存到指定目录
wget -P directory URL
#使用wget后台下载.
wget -b URL
#测试下载链接.
wget --spider URL

-http-user=user # 设置http用户名
-http-passwd=pass # 设置http密码

```

# 三. 文本处理

## 1. 正则表达式

- 正则表达式就是能用某种模式去匹配一类字符串的公式，它是由一串字符和元字符构成的字符
- 使用时最好使用单引号将正则表达式括起来，以免造成错误
- 正则表达式主要使用在对文件内容的匹配上，而通配符主要是用在文件名的匹配上
  
### 1. 元字符
- 注意：？ + | （） 这四个元字符属于扩展的正则表达式，使用它们时需要用egrep命令

元字符|含义|示例
|----|-----|---|
|.|用于匹配除换行符之外的任意一个字符||使用r..t就可以匹配root、ruut、r t（中间是两个空格）等
|\*|用于匹配前一个字符0次或任意多次|“\*”号经常和“.”符号加在一起使用。“.*”代表任意长度的不包含换行的字符
|?|用于匹配前一个字符0次或1次|
|+|用于匹配前一个字符1次以上|
|\\{n\\}|匹配前面的字符n次|
|\\{n,\\}|匹配前面的字符至少n次，包含n次||
|\\{n,m\\}|匹配前面的字符n到m次，包含n和m||
|^|用于匹配行开头的字符||^root匹配的是以字母root开始的行
|\$|用于匹配行结尾的字符|^\$则代表该行为空，因为^和\$间什么都没有，abc\$代表的是以abc结尾的行
|[ \]|用于匹配方括号内出现的任一字符|可以使用“-”号做范围限定，也可以加上^表示取反，[ABCD \]表示ABCD中的任一个，也可以用[A-D \]表示，而[^A-D \]表示匹配不是ABCD的字符。[0-9 \]\\{9\\}表示连续9个任意数字
|\\|转移字符
|\\<|界定单词的左边界|
|\\>|界定单词的右边界|可使用\\<  \\>用于精确匹配一个字符串，\\<hello\\>”可精确匹配单词hello,而不是helloworld等
|\||“或”的意思，即多种可能的罗列，彼此间是一种分支关系||
|( )|通常需要和“\|”符号联合使用，用于枚举一系列可替换的字符|用h(ar\|oo\|ol)匹配hard、hold或hood等这类开头和结尾的字母都一样的单词
|\\d|匹配一个数字，等价于[0-9 \]|是一种Perl兼容模式的表达式，又称PCRE,想要使用这种模式的匹配符需要加上-P参数
|\\b|匹配单词的边界|\bhello\b可精确匹配“hello”单词
|\\B|匹配非单词的边界|hello\B可以匹配“helloworld”中的“hello”
|\\w|匹配字母、数字和下划线,等价于'[A-Za-z0-9_ \]'|
|\\W|匹配非字母、数字和下划线,等价于'[^A-Za-z0-9_ \]'|
|\\n|匹配一个换行符|
|\\r|匹配一个回车符|
|\\t|匹配一个制表符|
|\\f|匹配一个换页符|
|\\s|匹配任何空白字符|
|\\S|匹配任何非空白字符|

### 2. 通配符
- 主要用来模糊搜索文件，使用它替代一个或多个真正的字符，尤其是在不知道或者不确定完整的文件名时，用来匹配符合条件的文件
  
通配符|含义|示例
|----|-----|---|
|\*|代表0个或多个字符|\*.doc就是指所有以.doc结尾的文件。如果想要找的文档是以字母A开头，则可用A*.doc来查找
|?|代表任意一个字符|
|{}|匹配括号内以逗号隔开的字符,还支持嵌套的通配|{A,B,C}.doc匹配以字母A、B、C开头，以.doc结尾的文件
|[ \]|用于匹配方括号内出现的任一字符|
|^ !|这两个符号往往和“[ \]”一起使用，当出现在“[]”中的时候，代表取反|[^A \]或[!A \]代表不是A。

## 2. 使用grep搜索文本

- Global search Regular Expression and print out the line
- 全面搜索正则表达式并打印出匹配行

```bash
grep [选项] 模式串 文件或目录（多个文件用空格隔开）

常用选项
    -e: 能匹配多个匹配样式，grep -e 模式串1 -e 模式串2 文件
    -E：能使用扩展的正则表达式匹配
    -i：忽略大小写，grep默认是区分大小的
    -n：打印行号
    -c：统计次数（一行算一次）
    -v: 反向匹配
    -r: 递归查找，适合在目录中查B找文件
    -o: 只输出文件中匹配到的部分
    -A <显示列数>: 除了显示符合范本样式的那一行之外，并显示该行之后的内容。
    -b: 在显示符合范本样式的那一行之外，并显示该行之前的内容
    -B <显示列数>: 除了显示符合范本样式的那一行之外，并显示该行之前的内容。
    -C <显示列数>或-<显示列数>: 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
```

## 3. 使用sort排序

```bash
sort [选项] 文件

选项:
    -d：按字典序排序（默认），默认按照每行第一个字符排序
    -n：按数字排序
    -t "c" : 指定c作为分隔符
    -k：-k n表示按各行第n列进行排序
    -r：反序
```

## 4. 使用uniq删除重复内容

- uniq一般都需要和sort命令一起使用，也就是先将文件使用sort进行排序（这样重复的内容就能显示在连续的几行中），然后再使用uniq删除掉重复的内容（uniq的作用就在于删除连续的完全一致的行）
- uniq命令只会对比相邻的行，如果有连续相同的若干行则删除重复内容，仅输出一行。如果相同的行非连续，则uniq命令不具备删除效果
  
```bash
uniq [选项] 文件

选项：
    -i: 忽略大小写
    -c: 计算重复行数
例如：
    cat uniq.txt|sort|uniq
```

## 5. 使用cut切分文本


```bash
cut [选项] 文件

选项：
    -d：分隔符（-d ':' 以’:‘为分隔符）
    -f：选择域（-f 1,2 输出分隔后第1列和第2列）
    -c：字符范围（-c n-m 输出第n到m个字符。如果没有m，输出到末尾）

#1.按’:‘分隔$PATH，输出第3个和第5个
echo $PATH | cut -d ':' -f 3,5

#2.输出export运行结果每行的第12-20个字符
export | cut -c 12-20
```

## 6. 使用tr做文本转换

```bash
#set1、set2为字符集，可以是单个字符，也可以是字符串
输出 | tr [选项] set1 set2

选项：
    -d：删除字符
    -s：字符压缩

#1.删除字符':'
cat /etc/passwd | tr -d ':'

#2.将小写字母替换成大写字母
last | tr '[a-z]' '[A-Z]'

#3.将'a'、'b'、'c'替换成'z'
cat test | tr “abc” 'z'

#4.将连续的'a'压缩成'b'（单个或连续出现的多个‘a’会压缩成一个‘b’）
cat test | tr -s 'a' 'b'

```


## 7. 使用paste拼接文本

- paste的作用在于将文件按照行进行合并，中间使用tab隔开
  
```bash
paste [选项] file1 file2

选项：
    -d：指定拼接时使用的分隔符（默认使用tab作为分隔符）
```

## 8. 使用split分割大文件

- 在Linux下使用split命令来实现文件的分割，支持按照行数分割和按照大小分割这两种模式
- 二进制文件因为没有“行”的概念，所以二进制文件无法使用行分割，而只能按照文件大小进行分割

```bash
split [选项] 要切割的文件 输出文件名(设置的是切割后文件的前置文件名， split会自动在前置文件名后再加上编号)

选项：
    -<n>: 指定每n行切成一个小文件
    -b<n>: 指定每n字节切成一个小文件
    -C<n>: 指定每n字节切成一个小文件,但是在切割时将尽量维持每行的完整性
```

## 9. 统计：wc

```bash
wc [选项] 文件

选项：
    -c：统计字符数
    -w：统计单词数
    -l：统计行数
```

## 10. 文本处理工具sed
- sed（stream editor），非交互式的流编辑器，通过多种转换修改流经它的文本
- 默认情况下，sed并不会改变原文件本身，而只是对流经sed命令的文本进行修改，并将修改后的结果打印到标准输出中（也就是屏幕。要想保存修改后的文件，必须使用重定向生成新的文件。如果想直接修改源文件本身则需要使用“-i”参数。
- sed处理文本时是以行为单位的，每处理完一行就立即打印出来，然后再处理下一行，直至全文处理结束
- 使用场景
  - 常规编辑器编辑困难的文本，太过于庞大的文本
  - 有规律的文本修改，加快文本处理速度
- sed 元字符，和正则表达式类似
  - ^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。
  - $ 匹配行结束，如：/sed$/匹配所有以sed结尾的行。
  - . 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。
  - \* 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。
  - \[ \] 匹配一个指定范围内的字符，如/\[ sS \]ed/匹配sed和Sed。  
  - \[ ^ \] 匹配一个不在指定范围内的字符，如：/\[ ^A-RT-Z \]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。
  - \\(..\\) 匹配子串，保存匹配的字符，如s/\\(love\\)able/\1rs，loveable被替换成lovers。\1表示第一个需要被保存的字符
  - & 保存搜索字符用来替换其他字符，如s/love/11&11/，love会被替换成11love11。
  - \\< 匹配单词的开始，如:/\\<love/匹配包含以love开头的单词的行。
  - \\> 匹配单词的结束，如/love\\>/匹配包含以love结尾的单词的行。
  - x\\{m\\} 重复字符x，m次，如：/0\\{5\\}/匹配包含5个0的行。
  - x\\{m,\\} 重复字符x，至少m次，如：/0\\{5,\\}/匹配至少有5个0的行。
  - x\\{m,n\\} 重复字符x，至少m次，不多于n次，如：/0\\{5,10\\}/匹配5~10个0的行。


```bash
sed [选项] '命令' 文件

多个命令用-e或;连接，例如sed -e 命令1 -e 命令2 文件 或 sed '命令1;命令2' 文件

选项：
    -n: 安静模式，只输出sed处理过的行（否则未处理行也会输出）
    -i: 结果直接作用到文件（没指定时不会修改文件）
    -e <script>: 以指定的脚本处理输入的文本
    -f <script文件>: 以指定的脚本文件处理输入的文本
    -h: 帮助信息
    -V: 版本信息

命令：
    <n>d: 删除第n行
    <n!>d: 删除n行之外的行
    <a,b>d: 删除第a-b行,可用$代表最后一行,同样可以在末尾加上！
    /模式串/d: 删除能够匹配字符串的行，sed '/^test/'d file
    D: 删除第一行

    s/字符串1/字符串2/<n>：把每行的前n个字符串1替换成字符串2，n默认为1
    s/字符串1/字符串2/<n>g：从第n处匹配开始替换，n默认为1

    y/字符串1/字符串2/: 将一系列字符逐个地变换为另外一系列字符，字符串12的长度必须相等
    例如：y/1234/ABCD/ 将数字1转换为A，2转换为B，3转换为C，4转换成D

    <n>i 文本 :在第n行前插入文本
    <n>a 文本 :在第n行后插入文本
    /模式串/[ia] 文本: 在能够匹配字符串的行前后插入文本

    <n>r 文件 或 /模式串/r 文件：和a类似，只是从从其他文件中读取文本，并插入匹配行之后

    <n>p :打印第n行
    -n '其他命令p' ：只打印执行了命令的行，要-n选项一起使用。
    
    {<a,b>,/模式串/} w 文件：把符合要求的行写到文件中
```


## 11. 文本处理工具awk

- sed其实是以行为单位的文本处理工具，而awk则是基于列的文本处理工具，它的工作方式是按行读取文本并视为一条记录，每条记录以字段分割成若干字段，然后输出各字段的值
- awk认为文件都是结构化的，也就是说都是由单词和各种空白字符组成的，这里的“空白字符”包括空格、Tab，以及连续的空格和Tab等。每个非空白的部分叫做“域”，从左到右依次是第一个域、第二个域，等等。 $1、$2分别用于表示域，$0则表示全部域
- awk处理步骤：
  1. 读入第一行，并将第一行的数据填入$0,$1,$2等变量当中
  2. 依据条件类型的限制，判断是否需要进行后面的动作
  3. 做完所有的动作与条件类型
  4. 若还有后续的“行”的数据，则重复1~3步，直到所有的数据都读完为止

```bash
awk '条件类型1{动作1} 条件类型2{动作2} ...' filename
输出 | awk '条件类型1{动作1} 条件类型2{动作2} ...'

变量：
    $0：整行
    $1：按分隔符分隔后的第1列
    $2：按分隔符分隔后的第2列
    $k：按分隔符分隔后的第k列
    NF：每一行拥有的字段数
    NR：目前所处理的行数
    FS：目前的分隔字符（默认是空格或tab）
条件判断：>、<、>=、<=、==、!=
命令分隔：使用';'或Enter
常见命令：
```

```bash
#1.打印last -n 5结果中每行经过分隔符(默认情况下为空格或tab)分隔后的第1列和第3列
last -n 5 | awk '{print $1 "\t" $3}'

#2.以':'作为分隔符，打印第3列小于10的所有行的第1列和第3列
cat /etc/passwd | awk '{FS=":"} $3<10{print $1 "\t" $3}'      #（第一行不会处理）
cat /etc/passwd | awk 'BEGIN{FS=":"} $3<10{print $1 "\t" $3}' #（第一行会处理）

#3.假设test文件由3列数字组成，以空格分隔。该命令会计算每行的和然后打印
awk '{total=$1+$2+$3;printf "%10d %10d %10d %10.2f\n",$1,$2,$3,total}' test
```

注意上面的示例2，awk首先是读取一行，分隔后的数据填入$0,$1,$2等变量中才开始进行条件判断和执行动作。因此第一条命令在按空格或tab分隔后才将分隔符换成':'，所以第一行显示结果不对





# 三，输入与输出

## 1.标准输出和输入
- 默认输出设备：标准输出，STDOUT，1
- 默认输入设备：标准输入，STDIN，0
- 标准错误输出：STDERR，2
- /dev/null文件，丢弃数据
  - 可以把/dev/null 可以看作"黑洞". 它等价于一个只写文件. 所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到

## 1. 重定向

- 在输出重定向中，>代表的是覆盖，>>代表的是追加。
- 输出重定向的完整写法其实是`fd>file`或者`fd>>file`，其中 fd 表示文件描述符，如果不写，默认为 1，也就是标准输出文件。
- fd和>之间不能有空格，否则 Shell 会解析失败；>和file之间的空格可有可无。为了保持一致，习惯在>两边都不加空格。
```bash
# 把CMD命令的标准输出重定向到一个文件中(如果文件存在，其内容将被覆盖)
command > filename
# 把CMD命令的标准输出重定向到一个文件中(追加文件尾部)
command >> filename
# 把CMD命令的标准错误重定向到一个文件中(如果文件存在，其内容将被覆盖)
command 2> filename
# 把CMD命令的标准错误重定向到一个文件中(追加文件尾部)
command 2>> filename
# 以覆盖的方式，把正确输出和错误信息同时保存到同一个文件（file）中。
# &1表示文件描述符 1,而1标识标准输出，stdout。
# 2>&1 的意思就是将标准错误重定向到标准输出
command >file 2>&1	
# 以追加的方式，把正确输出和错误信息同时保存到同一个文件（file）中。
command >>file 2>&1	
# 以覆盖的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中。
command >file1 2>file2
#以追加的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中。	
command >>file1  2>>file2	
```

- 和输出重定向类似，输入重定向的完整写法是`fd<file`，其中 fd 表示文件描述符，如果不写，默认为 0，也就是标准输入文件。
```bash
# 将 file 文件中的内容作为 command 的输入。
command <file
# 从标准输入（键盘）中读取数据，直到遇见分界符 end才停止（分界符可以是任意的字符串，用户自己定义）。	
command <<end	
# 将 file1 作为 command 的输入，并将 command 的处理结果输出到 file2
command <file1 >file2
```

## 3. 管道
- 管道是将前一个命令的输出作为后一个命令的输入，`命令1 | 命令2 | 命令3 | ......`
- 重定向操作符>将命令与文件连接起来，用文件来接收命令的输出；而管道符|将命令与命令连接起来，用第二个命令来接收第一个命令的输出
- Linux中的管道是一个固定大小的缓冲区，该缓冲区的大小为1页，即4K字节

# 三.进程管理

## 1.进程查询：ps

man ps手册非常庞大，不是很好查阅，因此主要记住几个命令

#### 示例

```bash
#1.列出仅与自身环境有关的进程，最上层的父进程是允许该ps命令的bash而没有扩展到init进程中去
ps -l

#2.列出系统所有进程的信息
ps aux
ps -ef    #aux会截断COMMAND列，-ef不会。aux是BSD风格，-ef是System V风格
ps axjf   #以"进程树"的方式显示所有进程
ps -lA    #输出格式同ps -l
```

![](../pic/linux-ps-1.png)

* **F**：进程标志，说明进程的权限
    - 4：root权限
    - 1：仅能fork而不能exec
    - 0：既非4也非1
* **S**：进程的状态
    - R(running)：正在运行
    - S(Sleep)：可被唤醒的睡眠
    - D：不可被唤醒的睡眠（通常可能在等待I/O）
    - T：停止，可能是在后台暂停
    - Z(Zombie)：僵尸进程
* **C**：CPU使用率
* **PRI/NI**：Priority/Nice的缩写，CPU优先级(越小越高)
* **ADDR/SZ/WCHAN**：内存相关，ADDR指出进程在内存的哪个部分，running进程一般显示'-'。SZ为进程使用的内存。WCHAN表示进程当前是否运行中'-'，当进程睡眠时，指出进程等待的事件
* **TTY**：进程运行的终端机
* **TIME**：进程用掉的CPU时间

![](../pic/linux-ps-2.png)

* **USER**：进程所属用户
* **%CPU/%MEM**：进程消耗的CPU百分比和内存百分比
* **VSZ**：进程用掉的虚拟内存(KB)
* **RSS**：进程占用的固定内存(KB)
* **TTY**：进程运行的终端机，与终端机无关则显示'?'。tty1~tty6是本机的登陆者程序，pts/0等表示由网络连接进主机的进程
* **STAT**：进程目前的状态，与```ps -l```结果中的**S**等同
* **START**：进程启动的时间
* **TIME**：进程实际使用的CPU运行时间

## 2.进程监控：top

#### 使用方法

```bash
top [选项]

选项：
    -d：跟秒数指定更新间隔
    -n：与-b搭配，指定需要进行几次top输出，重定向时常用
    -p：指定PID，监控特定进程
```

**top模式下的命令**：

* **?**：显示可用的命令
* **P**：以CPU使用情况排序
* **M**：以内存使用情况排序
* **N**：以PID排序
* **q**：退出
* **1**：多核情况下切换CPU

**%Cpu(s)后面的“wa”表示I/O wait，过高说明长时间等待I/O，I/O存在瓶颈**

## 3. 例行任务管理
- 如果任务是周期性执行的，其命令为cron
```bash
# 启动该进程
sudo service cron start
# 查看运行状态
sudo service cron status
# 关闭该进程
sudo service cron stop
# 启动该进程
sudo service cron restart
# 启动该进程
sudo service cron reload
# 设定指定 user 的时程表，这个前提是你必须要有其权限(比如说是 root)才能够指定他人的时程表,如果不使用 -u user 的话，就是表示设定自己的时程表。
crontab –u <user>
# 列出cron服务的详细内容 
crontab –l 
# 删除cron服务 
crontab –r 
# 编辑某个用户的cron服务
crontab –e 
```
- 语法结构`minute hour day month dayofweek command`
  - minute：从0到59的整数 
  - hour：从0到23的整数 
  - day：从1到31的整数 (必须是指定月份的有效日期)
  - month：从1到12的整数 (或如Jan或Feb简写的月份)
  - dayofweek：从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示)
  - 前五项为*时，代表每分钟/每小时。。。都执行一次任务
  - a-b/c，代表在第a到第b分钟内每隔c分钟执行一次任务，*/c则是每隔c分钟都执行一次
  - a,b,c 代表第a,b,c....分钟要执行一次
  - command：需要执行的命令(1、多行命令用“；”或者“&&”隔开，“；”不管命令是否出错都会连续执行下去，“&&” 出错则停止。 2、可以是脚本)
```bash
#下面是几个例子
* * * * * /bin/ls # 每一分钟执行一次 /bin/ls
0 6-12/3 * 12 * /usr/bin/backup #在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 /usr/bin/backup 
20 0-23/2 * * * echo "haha" #每月每天的 0 点 20 分, 2 点 20 分, 4 点 20 分.... 
0 */2 * * * /sbin/service httpd restart  # 意思是每两个小时重启一次apache 
50 7 * * * /sbin/service sshd start  # 意思是每天7：50开启ssh服务 
50 22 * * * /sbin/service sshd stop  # 意思是每天22：50关闭ssh服务 
0 0 1,15 * * fsck /home  # 每月1号和15号检查/home 磁盘 
1 * * * * /home/bruce/backup # 每小时的第一分执行 /home/bruce/backup这个文件 
30 6 */10 * * ls  # 意思是每月的1、11、21、31日的6：30执行一次ls命令
```

- 如果任务只是在某一个特定的时间执行一次，其命令为at
```bash
# 安排任务，用ctrl+D结尾
at <相对时间或绝对时间>
# 查看当前使用at命令调度的任务列表，第一列是任务编号
atq
# 删除已经进入任务队列的任务
atrm <任务编号>
```

## 3.打开文件查询：lsof

#### 使用方法

```bash
lsof [选项]

选项：
    -i：-i:端口号查看端口被占用的情况
    -u：后跟用户名查看具体用户打开的文件
    -p：后跟PID查看指定进程打开的文件
    +d：后跟目录查看指定目录下被进程打开的文件，"+D"递归
```

## 4.内存使用量：free

#### 使用方法

```bash
free [选项]

选项：
    -b|-k|-m|-g：单位
    -t：列出物理内存与swap的汇总情况    
```

![](../pic/linux-free-1.png)

* **buffers**：主要缓存dentry和inode等元数据
* **cached**：主要缓存文件内容，即page cache
* **- buffers/cache**：实际使用的内存。used-buffers-cached
* **+ buffers/cache**：可用内存。free+buffers+cached（在内存紧张时，buffers和cached可以回收）

[详细结果说明](https://fixatom.com/linux-free-cmd-buffers-and-cached/)

## 5.shell进程的资源限制：ulimit

#### 使用方法

```bash
ulimit [选项]       #查看
ulimit [选项] 新值  #修改

选项：
    -a：列出shell进程的所有资源限制情况（-a命令会列出查看某一资源限制的选项参数）
    ...
```

使用`ulimit`修改资源限制只会对当前终端环境有效，如果想永久生效，可以修改文件`/etc/security/limits.conf`，该文件的内容如下；

```bash
# /etc/security/limits.conf
#
#Each line describes a limit for a user in the form:
#
#<domain>        <type>  <item>  <value>
#
#Where:
#<domain> can be:
#        - a user name
#        - a group name, with @group syntax
#        - the wildcard *, for default entry
#        - the wildcard %, can be also used with %group syntax,
#                 for maxlogin limit
#        - NOTE: group and wildcard limits are not applied to root.
#          To apply a limit to the root user, <domain> must be
#          the literal username root.
#
#<type> can have the two values:
#        - "soft" for enforcing the soft limits
#        - "hard" for enforcing hard limits
#
#<item> can be one of the following:
#        - core - limits the core file size (KB)
#        - data - max data size (KB)
#        - fsize - maximum filesize (KB)
#        - memlock - max locked-in-memory address space (KB)
#        - nofile - max number of open files
#        - rss - max resident set size (KB)
#        - stack - max stack size (KB)
#        - cpu - max CPU time (MIN)
#        - nproc - max number of processes
#        - as - address space limit (KB)
#        - maxlogins - max number of logins for this user
#        - maxsyslogins - max number of logins on the system
#        - priority - the priority to run user process with
#        - locks - max number of file locks the user can hold
#        - sigpending - max number of pending signals
#        - msgqueue - max memory used by POSIX message queues (bytes)
#        - nice - max nice priority allowed to raise to values: [-20, 19]
#        - rtprio - max realtime priority
#        - chroot - change root to directory (Debian-specific)
#
#<domain>      <type>  <item>         <value>
#

#*               soft    core            0
#root            hard    core            100000
#*               hard    rss             10000
#@student        hard    nproc           20
#@faculty        soft    nproc           20
#@faculty        hard    nproc           50
#ftp             hard    nproc           0
#ftp             -       chroot          /ftp
#@student        -       maxlogins       4

# End of file
```

#### 示例

```bash
root@068ca8da6d06:/# ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7863
max locked memory       (kbytes, -l) 82000
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1048576
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) unlimited
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

# 四.网络工具

## 1.网卡配置：ifconfig

## 2.查看当前网络连接：netstat

```bash
netstat [选项]

选项：
    -a：将所有的连接、监听、Socket数据都列出来（如，默认情况下，不会列出监听状态的连接）
    -t：列出tcp连接
    -u：列出udp连接
    -n：将连接的进程服务名称以端口号显示（如下图中Local Address会换成10.0.2.15:22）
    -l：列出处于监听状态的连接
    -p：添加一列，显示网络服务进程的PID（需要root权限）
    -i：显示网络接口列表，可以配合ifconfig一起分析
    -s：打印网络统计数据，包括某个协议下的收发包数量
```

![](../pic/linux-netstat-1.png)

* **Active Internet connections（w/o servers）：网络相关的连接**
    - **Recv-Q**：接收队列(已接收还未递交给应用)
    - **Send-Q**：发送队列(接收方未确认的数据)
    - **Local Address**：本地IP(主机):端口(服务名)
    - **Foreign Address**：远端IP:端口
    - >Recv-Q和Send-Q通常应该为0，如果长时间不为0可能存在问题
* **Active UNIX domain sockets（w/o servers）：本地相关的套接字**
    - **RefCnt**：连接到此socket的进程数
    - **Flags**：连接标识
    - **Type**：socket访问的类型
    - **Path**：连接到此socket的相关程序的路径

[netstat的10个基本用法](https://linux.cn/article-2434-1.html)

## 3.查看路由表：route

## 4.检查网络连通性：ping

## 5.转发路径：traceroute

## 6.网络Debug分析：nc

## 7.命令行抓包：tcpdump

#### 使用方法

```bash
sudo tcpdump [选项] ...

选项：
    -D/-i：查看/指定网卡
```

#### 示例

```bash
#抓取本地9877号端口的TCP数据包
sudo tcpdump -i lo tcp port 9877
```

下图为tcp回射服务器，客户端分别键入"hello"和“world”时，使用tcpdump抓取到的数据包

<div align="center"> <img src="../pic/linux-tcpdump-1.png"/> </div>

## 8.域名解析工具：dig

## 9.网络请求：curl

# 五.开发及调试

## 1.编辑器：vim

## 2.编译器：gcc和g++

[C程序的编译过程](https://www.cnblogs.com/CarpenterLee/p/5994681.html)

#### 使用方法

```bash
gcc/g++ [选项] 源文件

选项：
    -E：让编译器在预处理之后停止，不进行后续编译过程，得到.i文件
    -S：让编译器在编译之后停止 ，不进行后续过程，得到.s文件
    -c：生成机器码即二进制.o文件
    -o：指定目标文件名
    -g：在编译的时候生成调试信息
    -Wall：生成所有警告信息
    -I 目录：指定头文件的查找目录
    生成动态链接库：
        1. gcc/g++ -c -fPIC 源文件 -o 目标文件名
        2. gcc -shared 目标文件名 -o 动态链接库名.so
    生成静态链接库：
        1. gcc/g++ -c 源文件 -o 目标文件名
        2. ar -crv 静态链接库名.a 目标文件名
    -l库名 -L 目录：引入链接库，-L指定查找该库的目录。如-lm表示引入libm.so
```

## 3.调试工具：gdb

#### 使用方法

```bash
#第一步：得到可执行文件
gcc/g++ -o 可执行文件 -g 源文件

#第二步：启动gdb
gdb #启动gdb

#第三步：执行gdb命令进行调试
(gdb) gdb命令

gdb命令：
    file 可执行文件：导入需要调试的文件
    r：运行程序
    q：退出gdb
    b：设置断点
        b 行号
        b 函数名称
        b *函数名
        b *代码地址
        b 编号
    c：继续执行，直到下一断点或程序结束
    s：执行一行代码，如果此行代码有函数调用则进入函数
    n：执行一行代码，如果此行代码有函数调用，不进入函数，直接执行函数
    i(info) 子命令：查看某些信息（只输入info或i可以查看有哪些子命令）
        info thread：查看进程的所有线程，会显示每个线程的序号（1~n）
    thread 线程序号：切换到相应的线程（线程序号可以由info thread得到）
    f(frame) 函数栈帧号：切换到相应的函数栈帧（函数栈帧号可以由where等命令得到）
    list：查看源码
        list 行号：查看指定行号附近的源码
        list 函数：查看指定函数附近的源码
        list 文件:行号：查看指定文件中指定行附近的代码
    where：查看当前位置
    p(print) /格式 表达式
        格式：
            x：按十六进制格式显示变量
            d：按十进制格式显示变量
            u：按十六进制格式显示无符号整形
            o：按八进制格式显示变量
            t：按二进制格式显示变量
            a：按十六进制格式显示变量
            c：按字符格式显示变量
            f：按浮点数格式显示变量
        表达式中可用的操作符：
            @：一个和数组有关的操作符，左边是起始地址，右边是长度（p *arr@3）
            ::：指定一个在文件或是函数中的变量（p 'f2.c'::x）
            {<type>}<addr>：一个指向内存<addr>的类型为type的一个对象
    x(examine) <n/f/u> <addr>：查看内存
        n：正整数，表示需要显示的内存单元个数
        f：显示的格式（格式字母同上面的print）
        u：每个单元的字节数
            b：1字节
            h：2字节
            w：4字节（默认）
            g：8字节
```

## 4.查看依赖库：ldd

## 5.二进制文件分析：objdump

## 6.ELF文件格式分析：readelf

## 7.跟踪进程中系统调用：strace

## 8.跟踪进程栈：pstack

## 9.进程内存映射：pmap

# 六.其他

## 1.终止进程：kill

## 2.修改文件权限：chmod

* w权限不具有删除文件的能力
* 目录的x权限表示能否进入目录

#### 使用方法

```bash
chmod [选项] [u|g|o|a][+|-][r|w|x] 文件或目录
chmod [选项] 权限的数字表示 文件或目录

选项：
    -R：递归式的修改
```

## 3.创建链接：ln

## 4.显示文件尾：tail

## 5.版本控制：git

## 6.设置别名：alias
